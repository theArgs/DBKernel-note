Makefile文件描述了整个工程的编译、连接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建哪些库文件以及如何创建这些库文件、如何最后产生我们想要的可执行文件。

make是一个命令工具，它解释Makefile中的指令，Makefile文件中描述了整个工程所有文件的编译顺序、编译规则。

**仅了解，后续一般不直接写Makefile而是使用CMake**。

## 1 基本概念

### 1.1 Makefile的内容

一个完整的Makefile中，包含了5个东西：显式规则、隐含规则、变量定义、指示符和注释。

* 显式规则：描述了在何种情况下如何更新一个或多个被称为目标的文件。书写Makefile时需要明确地给出目标文件、目标的依赖文件列表以及更新目标文件所需要的命令（有些规则没有命令，这样的规则只是纯粹的描述了文件之间的依赖关系）。
* 隐含规则：是make根据一类目标文件（典型的是根据文件名的后缀）而自动推导出来的规则。make根据目标文件名，自动产生目标的依赖文件并使用默认的命令来对目标进行更新（建立一个规则）。
* 变量定义：使用一个字符或字符串代表一段文本串，当定义了一个变量后，Makefile后续在需要使用此文本的地方，通过引用这个变量来实现对文本串的使用。
* Makefile指示符：指示符指明在make程序读取makefile文件过程中所要执行的一个动作，包括：
  * 读取一个文件，读取给定文件名的文件，将其内容作为makefile文件的一部分。
  * 决定（通常是根据一个变量的值）处理或者忽略Makefile中的某一特定部分。
  * 定义一个多行变量。
* 注释：Makefile中”#“字符后的内容被作为是注释内容处理。如果此行的第一个非空字符为“#“，那么此行为注释行。注释行的结尾如果有反斜线（\\)，那么下一行也被当成注释行。当在Makefile中需要使用字符”#“时，可以使用反斜线加”#“来实现。

**注意：**

Makefile中第一个规则之后的所有以[Tab]字符开始的行，make程序都会将其交给系统shell程序去解释执行。因此，以[Tab]字符开始的注释行也会被交给shell来处理，此命令行是否需要被执行是由系统shell程序来判决的。

在使用指示符“define”定义一个多行的变量或者命令包时，其定义体（“define”和“endef”之间的内容）会被完整的展开到Makefile中引用此变量的地方（包括注释行）；make在引用此变量的地方对所有的定义体进行处理，决定是注释还是有效内容。

Makefile中变量的引用和C语言中的宏类似，对一个变量引用的地方make所做的就是将这个变量根据定义进行基于文本的展开，展开变量的过程不涉及到任何变量的具体含义和功能分析。

### 1.2 Makefile文件的命名

默认情况下，make会在工作目录（执行make的目录）下按照文件名顺序寻找makefile读取并执行。推荐使用“Makefile”。

可以通过`-f`或者`--file`选项来指定make读取的Makefile文件，格式为：`-f NAME`或`--file=NAME`。如果指定了多个需要读取的Makefile文件，这些文件会按照指定的顺序进行连接并被make解析执行。

### 1.3 包含其他Makefile文件

“include”指示符告诉make暂停读取当前的Makefile，而转去读取“include”指定的一个或者多个文件，完成以后再继续当前Makefile的读取。

Makefile中指示符“include”书写在独立的一行。

``` makefile
include FILENAMES...
```

“include”和文件名之间、多个文件之间使用空格隔开。FILENAMES是shell所支持的文件名，可以使用通配符。

使用指示符包含进来的Makefile中，如果存在变量或者函数的引用，它们将会在包含它们的Makefile中被展开。

以下场合使用：

1. 有多个不同的程序，由不同目录下的几个独立的Makefile来描述其重建规则。它们使用一组通用的变量定义或者模式规则。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，在需要使用的Makefile中使用指示符“include”来包含此文件。
2. 根据源文件自动产生依赖文件时；可以将自动产生的依赖关系保存在另一个文件中，主Makefile使用指示符“include”包含这些文件。

可使用“-include”来代替“include”，来忽略由于包含文件不存在或者无法创建时的错误。

### 1.4 变量MAKEFILES

如果在当前环境定义了一个“MAKEFILE”环境变量，make执行时首先将此变量的值作为需要读入的Makefile文件，多个文件之间使用空格分开。和“include”的区别：

1. 环境变量指定的Makefile文件中的“目标”不会被作为make执行的终极目标。
2. 环境变量所定义的文件列表，在执行make时，如果不能找到其中某一个文件，make不会提示错误，也不退出。
3. make在执行时，首先读取的是环境变量“MAKEFILES“所指定的文件列表，之后才是工作目录下的Makefile文件。

很少用此变量，主要用在make的递归调用过程中的通信。

可以使用此环境变量来指定一个定义了通用隐含规则和变量的文件，比如设置默认搜索路径。

推荐使用“include”。

### 1.5 变量MAKEFILE_LIST

make程序在读取多个Makefile文件时，包括由环境变量“MAKEFILES”指定、命令行指定、当前工作目录下的默认的以及使用指示符“include”指定包含的。在对这些文件进行解析之前，make读取的文件名会被自动追加到变量“MAKEFILE_LIST”中。

### 1.6 执行过程

make的执行过程如下：

1. 依次读取变量“MAKEFILES”定义的Makefile文件列表。
2. 读取工作目录下的Makefile文件。
3. 依次读取工作目录Makefile文件中使用指示符“include”包含的文件。
4. 查找重建所有已读取的Makefile文件的规则。
5. 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支。
6. 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表。
7. 执行除“终极目标”以外的所有的目标的规则。
8. 执行“终极目标”所在的规则。

## 2 规则

规则描述了在何种情况下使用什么命令来重建一个特定的文件，此文件被称为规则“目标”。规则中除目标之外的罗列的其他文件称为“目标”的依赖，而规则的命令是用来更新或创建此规则的目标。

### 2.1 规则语法

通常规则的语法格式如下：

``` makefile
TARGETS : PREREQUISITES
	COMMAND
```

命令行必须以[Tab]字符开始。在Makefile中，第一个规则之后出现的所有以[Tab]字符开始的行都会被当做命令来处理。

Makefile中符号“$”有特殊的含义（表示变量或者函数的引用），在规则中需要使用符号“$”的地方，需要书写两个连续的“$$”。

对于Makefile中一个较长的行，使用反斜线“\\”将其书写到几个独立的物理行上。

规则的中心思想是：目标文件的内容是由依赖文件决定，依赖文件的任何一处改动，将导致目前已经存在的目标文件的内容过期，规则的命令为重建目标提供了方法。

### 2.2 文件名使用通配符

Makefile中表示文件名时可以使用通配符，可使用的通配符有：“*”、“?”、“[...]”。

Makefile中通配符可以出现在以下两种场合：

1. 可以用在规则的目标、依赖中，make在读取Makefile时会自动对其进行匹配处理（通配符展开）。
2. 可出现在规则的命令中，通配符的通配处理是在shell执行此命令时完成的。

除了这两种情况外的其他上下文中，不能直接使用通配符，而是需要通过函数“wildcard”来实现。

#### 2.2.1 通配符使用

``` makefile
clean :
	rm -f *.o
```

``` makefile
print : *.c
	lpr -p $?
	touch print
```

自动变量“$?”表示依赖文件列表中被改变过的所有文件。

#### 2.2.2 通配符缺陷

变量定义中使用的通配符不会被通配处理（因此在变量定义中不能使用通配符，否则在某些情况下会出现非预期的结果），需要使用函数“wildcard”。

#### 2.2.3 函数wildcard

在规则中，通配符会自动展开，变量定义和函数引用时，通配符将会失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”。用法是：`$(wildcard RATTERN)`。在Makefile中，它被展开为已存在的，使用空格分开的，匹配此模式的所有文件列表。

一般可以使用`$(wildcard *.c)`来获取工作目录下的所有`.c`文件列表。可以使用`$(patsubst %.c, %.o, $(wildcard *.c))`得到当前目录可生成的`.o`文件列表。

### 2.3 目录搜寻

较大工程中，一般会将源代码和二进制文件安排在不同目录进行区分管理。可以使用make提供的目录

搜索依赖文件功能（在指定的若干个目录下自动搜索依赖文件）。

#### 2.3.1 一般搜索

可以识别特殊变量“VPATH”，通过变量“VPATH”可以指定依赖文件的搜索路径，当规则的依赖文件在当前目录不存在时，make会根据此变量所指定的目录下去寻找这些依赖文件。

定义变量“VPATH”时，使用空格或者冒号将多个需要搜索的目录分开。

``` makefile
VPATH = src:../headers
```

#### 2.3.2 选择性搜索

使用“vpath”关键字，可以为不同类型的文件（由文件名区分）指定不同的搜索目录。

使用的方法有3种：

1. `vpath PATTERN DIRECTORIES`：为所有符合模式“PATTERN”的文件指定搜索目录“DIRECTORIES”，多个目录使用空格或冒号分开。
2. `vpath PATTERN`：清除之前为符合模式“PATTERN”的文件设置的搜索路径。
3. `vpath`：清除所有已被设置的文件搜索路径。

“PATTERN”需要包含模式字符“%”，意思是匹配一个或者多个字符。

``` makefile
vpath %.h ../headers
```

其含义是：Makefile中出现的`.h`文件，如果不能在当前目录下找到，则到目录“../headers”下寻找。

#### 2.3.3 命令行和搜索目录

make在执行时，通过目录搜索得到的目标的依赖文件可能会在其他目录（此时依赖文件为文件的完整路径名），但是已经存在的规则命令不能变化。因此书写命令时必须保证当依赖文件在其他目录下被发现时规则的命令能够正确执行。

解决这个问题的方式是在规则的命令行中使用“自动化变量”，如“$^”等。

“$^”代表所有通过目录搜索得到的依赖文件的完成路径列表。“$@”代表规则的目标。

``` makefile
foo.o : foo.c
	cc -c $(CFLAGS) $^ -o $@
```

规则的依赖文件列表中可以包含头文件，而在命令行中不需要使用这些头文件（这些头文件的作用只有在make程序决定目标是否重建时才有意义）。可以用另外一个变量代替“$^”。

``` makefile
VPATH = src:../headers
foo.o : foo.c defs.h hack.h
	cc -c $(CFLAGS) $< -o $@
```

自动化变量“$<”代表规则中通过目录搜索得到的依赖文件列表的第一个依赖文件。

### 2.4 伪目标

伪目标不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。

常见的clean目标：

``` makefile
clean :
	rm *.o temp
```

将一个目标声明为伪目标的方法是将它作为特殊目标`.PHONY`的依赖：

``` makefile
.PHONY : clean
```

这样目标“clean”就被声明为一个伪目标，无论当前目录下是否存在“clean”这个文件，输入`make clean`后，命令都会被执行。

### 2.5 静态模式

静态模式是这样的一个规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。

**语法：**

``` makefile
TARGETS... : TARGET-PATTERN : PREREQ-PATTERNS...
	COMMANDS
```

“TARGETS”列出了此规则的一系列目标文件。

“TARGET-PATTERN”和“PREREQ-PATTERNS”说明了如何为每一个目标文件生成依赖文件。在目标模式和依赖模式中，一般需要包含模式字符“%”，在目标模式（TARGET-PATTERN）中模式字符“%”匹配的部分称为“茎”。使用“茎”替代依赖模式（PREREQ-PATTERNS）中的相应部分来产生对应目标的依赖文件。目标模式中“%”可以匹配目标文件的任何部分，目标文件和目标模式的其余部分必须精确匹配。

## 2.6 自动产生依赖

gcc通过`-M`选项自动找寻源文件中包含的头文件，并生成文件的依赖关系。`-M`选项包含对标准库的头文件的依赖关系描述，当不需要在依赖关系中考虑标准库头文件时，使用`-MM`参数。

## 3 变量

在Makefile中，变量是一个名字，代表一个文本字符串。在Makefile的目标、依赖、命令中引用变量的地方，变量会被它的值所取代。

变量使用“=”定义，定义一个变量后，就可以在其他地方引用此变量。

``` makefile
objects = program.o foo.o utils.o
program : $(objects)
	cc -o program $(objects)
```

## 4 函数

### 4.1 函数的调用语法

``` makefile
$(FUNCTION ARGUMENTS)
```

### 4.2 patsubst

``` makefile
$(patsubst PATTERN, REPLACEMENT, TEXT)
```

模式替换函数：patsubst。搜索“TEXT”中以空格分开的单词，将符合模式的“PATTERN”替换为“REPLACEMENT”，参数“PATTERN”中可以使用模式通配符“%”来代表一个单词中的若干字符。如果参数“REPLACEMENT”中也包含一个“%”，那么“REPLACEMENT”中的“%”将是“PATTERN”中的那个“%”所代表的字符串。返回替换后的新字符串。

### 4.3 wildcard

``` makefile
$(wildcard PATTERN)
```

获取匹配模式文件名函数：wildcard。列出当前目录下所有符合模式“PATTERN”格式的文件名。返回空格分割的、存在当前目录下的所有符合模式的文件名。

### 4.4 示例

``` makefile
src = $(wildcard ./*.c)
obj = $(patsubst %.c, %.o, $(src))
#...
```

## 5 隐含规则

隐含规则为make提供了重建一类目标文件的通用方法，不需要在Makefile中明确地给出重建特定目标文件所需要的细节描述。

## 5.1 隐含规则

**编译C程序**

`.o`文件自动由`.c`生成，执行命令为`$(CC) -c $(CPPFLAGS) $(CFLAGS)`。

**编译C++程序**

`.o`自动由`.cc`生成，执行命令为`$(CXX) -c $(CPPFLAGS) $(CFLAGS)`。

### 5.2 隐含变量

**代表命令的变量**

`CC`：C编译程序，默认是`cc`。

`CXX`：C++编译程序，默认是`g++`。

`RM`：删除命令，默认是`rm -f`。

### 5.3 模式规则

模式规则类似于普通规则。只是在模式规则中，目标名中需要包含有模式字符“%”，包含有模式字符“%”的目标被用来匹配一个文件名，“%”可以匹配任意非空字符串。规则的依赖文件中同样可以使用“%”，依赖文件中模式字符“%”的取值情况由目标中的“%”来决定。

## 6 执行make

最简单直接的方法就是使用不带任何参数的“make”命令来重新编译所有过时的文件。

### 6.1 指定Makefile文件

当需要将一个普通命名的文件作为Makefile文件时，需要使用make的`-f`、`--file`或者`--makefile`选项来指定。

### 6.2 指定终极目标

在Makefile中使用`ALL:`指定终极目标。
