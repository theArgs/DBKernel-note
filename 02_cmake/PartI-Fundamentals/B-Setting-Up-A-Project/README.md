## 2 Setting Up A Project

如果没有构建系统，则项目仅仅是一些文件的集合。CMake通过使用名为CMakeLists.txt的文件为项目中文件的集合定义了一些规则，CMakeLists.txt文件定义了构建的内容、如何构建、运行哪些测试以及创建哪些包。CMakeLists.txt是普通的文本文件且是平台无关的，CMake会将其转换为对应平台特定的构建工具的项目文件。此文件的内容将在后续章节详细介绍，但目前，只要知道它的作用就是控制CMake在设置和执行构建过程就足够了。

CMake的一个基本概念是一个项目同时具有源目录（source directory）和二进制目录（binary directory）。源目录是CMakeLists.txt文件所在的位置，项目的源文件和一些其他构建所需要的文件也组织在这个目录下。源目录通常使用git、subversion或类似的工具进行版本控制。

二进制目录是构建过程生成的文件放置的位置，通常也被称为构建目录（build directory）。CMake通常使用二进制目录一词，而开发人员通常使用构建目录，更加直观。CMake、构建工具（例如make、Visual Studio等）、CTest和CPack等都将在构建目录及其子目录中创建各种文件。可执行文件、库、测试输出和包也都在构建目录中创建，此外，CMake还在构建目录中创建一个名为CMakeCache.txt的文件存储变量信息，以便在后续运行中复用。开发人员通常不需要关心CMakeCaChe.txt文件，但在后续的章节中我们将讨论一些此文件相关的内容。构建工具的项目文件（例如Xcode或Visual Studio项目文件、Makefiles等）同样应该在构建目录中生成，不应该由版本管理工具控制。CMakeLists.txt文件是项目的正确描述，其生成的项目文件应该认为是构建时输出的一部分。

当开发人员创建项目时，必须确认构建目录应该放置在哪里，相对于源目录来说有两种方法：源内构建（in-source builds）和源外构建（out-of-source builds）。

### 2.1 In-source Builds 

不鼓励使用这种方式。源目录和构建目录可能相同，这种方式被称为源内构建。新手开发者通常使用这种方法，因为他们认为这种方法比较简单。但是，源内构建的主要麻烦是它将所有的构建输出都与源文件混合在了一起。源目录和构建目录缺少隔离会导致同一个目录中充斥着各种文件和子目录，使得管理项目更加困难，并且存在构建的输出覆盖源文件的风险。这种方式也让代码的版本控制变得困难，因为有许多的文件由构建创建的，那么版本控制工具必须知道哪些需要忽略或者开发人员必须在提交时手动排除这些文件。源内构建的另一个缺点是很难方便的清除所有构建输出并还原到原始代码树。所以，即使对于简单的项目，开发人员也不应该使用源内构建。

### 2.2 Out-of-source Builds

另一种更好的方式是将源目录和构建目录分开，这种方式称为源外构建，它避免了源内构建中的各种缺点。源外构建的另一个优点是开发人员可以为同一个源目录创建多个使用不同选项设置的构建目录，例如调试和发布版本等等。

本书将始终使用源外构建，并将源目录和构建目录置于相同父级目录下，构建目录通常命名为`build`。例如：

<img src="img\01.png" alt="01" />

一些开发人员使用的另一种方式是使构建目录成为源目录的子目录，这种方式有源外构建的大部分优势，但仍然具有源内构建的一些缺点。除非有充足的理由以这种方式组织文件，否则还是推荐将构建目录完全置于源代码树之外。

### 2.3 Generating Project Files

在决定了目录结构之后，开发人员会运行CMake，CMake读取CMakeLists.txt文件，并在构建目录中创建项目文件。开发人员通过使用对应的项目文件`generator`来选择要创建的项目文件的类型。CMake支持一系列不同的生成器，一些生成器可以生成支持多种配置的项目（例如调试、发布等），允许开发人员在不重新运行CMake的情况下可以在不同构建配置之间进行选择，更适合在Xcode和Visual Studio等IDE环境中使用。而对于不支持多个配置的生成器，开发者需要重新运行CMake才能在调试、发布等之间进行切换构建模式，这种方法更加简单，并且在与特定编译器关键不紧密的IDE环境（Qt Creator、KDevelop等）中通常有很好的支持。

<img src="img\02.png" alt="02" />

运行CMake的最基本方法是在命令行终端中执行`cmake`命令，通常是切换到构建目录，然后将生成器类型和源码树位置传递给`cmake`。

``` shell
mkdir build
cd build
cmake -G "Unix Makefiles" ../source
```

如果省略`-G`选项，则CMake将根据执行平台选择默认的生成器类型。无论哪种生成器类型，CMake会执行一系列动作来确认如何设置项目文件，包括验证编译器是否工作、确认编译器支持的功能集合和一些其他任务。CMake在执行时会记录各种信息，如果执行成功，则会在结尾时有如下类似信息：

``` shell
-- Configuring done
-- Generating done
-- Build files have been written to: /some/path/build
```

构建项目文件实际上包含两个步骤：配置和生成。在配置阶段，CMake读取CMakeLists.txt文件，并建立整个项目的内部表示。完整配置后，生成阶段将创建项目文件。在简单使用CMake时，两个阶段的区别并不重要，但后续深入学习中，需要重视两个阶段的概念，我们将在以后进行讨论。

当CMake运行完成后，它将在构建目录中保存一个CMakeCache.txt文件，CMake使用此文件来保存一些信息以便于在CMake重新执行时能够复用这些信息，加快项目生成速度。它还允许在运行时保存开发人员选项。图形应用程序`cmake-gui`可以作为运行`cmake`命令的替代方案，但它的作用在使用变量时更加明显，我们将在后续章节讨论它。

### 2.4 Running The Build Tool

现在，项目文件已经被创建出来，开发人员可以根据选择的项目文件类型使用对应的构建工具了。构建目录中包含了必要的项目文件，这些文件可以加载到IDE中或者通过命令行工具读取等。CMake也可以帮助开发人员调用工具，例如：

``` shell
cmake --build /some/path/build --config Debug --target MyApp
```

这种方式同样适用于Xcode或Visual Studio等IDE所使用的项目类型。`--build`选项指定CMake项目使用的构建目录，对于多配置生成器，`--config`选项指定要生成的构建类型，而单配置生成器则会忽略`--config`选项，使用CMake项目生成步骤中使用并提供的信息，构建类型将在第13章进行介绍。`--target`选项指明要构建的内容，如果省略，将构建默认目标。

虽然代码人员通常会在开发中直接调用选定的构建工具，但通过在脚本中使用cmake命令来调用构建工具自动构建可能更加有用。

``` shell
mkdir build
cd build
cmake -G "Unix Makefiles" ../source
cmake --build . --config Release --target MyApp
```

如果开发人员希望尝试不同的生成器，仅需修改`-G`选项，`cmake`将会调用正确的构建工具。

### 2.5 Recommended Practices

即使是第一次使用CMake，也应该养成将构建目录和源代码树完全分开的习惯。体验这种方式的好处的一个好方法是为同一个源目录设置两个或更多不同的构建，一个可以使用`Debug`构建类型，另一个使用`Release`构建类型。另一种方法是在不同的构建目录中使用不同的项目生成器，例如Unix Makefiles和Xcode，这样有助于理解特定构建工具的依赖关系或检查不同生成器类型之间的不同编译器设置。

在项目早期阶段，专注于使用一种特定类型的项目生成器是很诱人的，特别是在开发人员不习惯编写跨平台软件的情况下。然而，项目常常需要支持更多的平台，因此需要不同的生成器类型，定期的使用不同的项目生成器执行构建，来检查是否有不必要的平台相关的代码，可以在后续减少大量代码的改动。定期构建的另一个好处是使得项目在后续可以使用任何新的生成器。一种好的方式是确保项目除了使用目标平台上的默认生成器进行构建外也使用另一个生成器进行构建。`Ninja`生成器是后者的一个绝佳选择，因为它拥有所有生成器中最广泛的平台支持，而且它的构建十分高效。如果项目包含脚本，那么就通过`cmake --build`来调用构建工具，而不是直接使用，这允许脚本在不同的生成器类型之间轻松切换。

